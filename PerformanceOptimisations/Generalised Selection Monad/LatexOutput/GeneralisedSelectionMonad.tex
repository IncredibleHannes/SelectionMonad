% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}

\usepackage{listings}
\usepackage{textcomp}
\usepackage[english]{babel}

\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}

\lstnewenvironment{code}{\lstset{language=Haskell,basicstyle=\small\ttfamily}}{}
\newcommand{\ignore}[1]{}


\begin{document}

\title{Generalised Selection Monad}

\author{
    Johannes Hartmann\inst{1} \and 
    Tom Schrijvers\inst{2}\and 
    Jeremy Gibbons\inst{1}
}
%
\authorrunning{J. Hartmann, T. Schrijvers, J. Gibbons}

\institute{
    University of Oxford, Department of Computer Science, UK
    \email{firstname.lastname@cs.ox.ac.uk}\and 
    KULeuven, DepartmentofComputerScience, Belgium,
    \email{tom.schrijvers@kuleuven.be}
}

%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
General setup and introduction words here

\keywords{Selection monad  \and Functional programming \and Algorithm design \and 
Performance Optimisation \and Monads.}
\end{abstract}
%
%
%
\ignore{

> {-# LANGUAGE ImpredicativeTypes #-}
> {-# LANGUAGE ScopedTypeVariables #-}

> import Prelude hiding ((>>=), return, pure, (<*>), fmap, sequence, Left, Right)

}

\section{Introduction to the Selection
Monad}\label{introduction-to-the-selection-monad}

This section introduces the selection monad, focusing on the
\texttt{type\ J\ r\ a\ =\ (a\ -\textgreater{}\ r)\ -\textgreater{}\ a}
for selection functions. The \texttt{pair} function is explored,
showcasing its capability to compute new selection functions based on
criteria from two existing functions. Illustrated with a practical
example, the decision-making scenarios involving individuals navigating
paths underscore the functionality of selection functions. An analysis
of the inefficiency in the original \texttt{pair} function identifies
redundant computational work. The primary contribution of the paper is
then outlined: an illustration and proposal for an efficient solution to
enhance \texttt{pair} function performance. This introductory overview
sets the stage for a detailed exploration of the selection monad and
subsequent discussions on optimizations.

\subsection{Selection functions}\label{selection-functions}

Consider the tollowing already know type for selection functions:

\begin{code}
type J r a = (a -> r) -> a
\end{code}

When given two selection functions, a \texttt{pair} function can be
defined to compute a new selection function. This resultant function
selects a pair based on the criteria established by the two given
selection functions:

\begin{code}
pair :: J r a -> J r b -> J r (a,b)
pair f g p = (a,b)
  where
      a = f (\x -> p (x, g (\y -> p (x,y))))
      b = g (\y -> p (a,y))
\end{code}

\subsection{Example to illustrate the pair
function}\label{example-to-illustrate-the-pair-function}

To gain a deeper understanding of the provided \texttt{pair} function,
consider the following example. Picture two individuals walking on a
path, one heading north and the other south. As they proceed, a
collision is imminent. At this juncture, each individual must make a
decision regarding their next move. This decision-making process can be
modeled using selection functions. The decision they need to make is
modeled as either going right or left:

\begin{code}
data Decision = Left | Right
\end{code}

The respective selection functions decide given a predicate that tells
them what decision is the correct one, select the correct one, and if
there is no correct one, they default to walking right.

\begin{code}
p1, p2 :: J Bool Decision
p1 p = if p Left then Left else Right
p2 p = if p Left then Left else Right
\end{code}

To apply the \texttt{pair} function, a predicate \texttt{pred} is needed
that will judge two decisions and return \texttt{True} if a crash would
be avoided and \texttt{False} otherwise.

\begin{code}
pred :: (Decision, Decision) -> Bool
pred (Left,Right) = True
pred (Right,Left) = True
pred _            = False
\end{code}

With the \texttt{pair} function, the merging of the two selection
functions into a new one that identifies an optimal decision can now be
calculated.

\begin{verbatim}
pair p1 p2 pred
--> (Left,Right)
\end{verbatim}

Examining how the \texttt{pair} function is defined reveals that the
first element \texttt{a} of the pair is determined by applying the
initial selection function \texttt{f} to a newly constructed property
function. Intuitively, selection functions can be conceptualized as
entities containing a collection of objects, waiting for a property
function to assess their underlying elements. Once equipped with a
property function, they can apply it to their elements and select an
optimal one. Considering the types assigned to selection functions, it
is evident that an initial selection function \texttt{f} remains in
anticipation of a property function of type
\texttt{(a\ -\textgreater{}\ r)} to determine an optimal \texttt{a}. The
\texttt{pair} function is endowed with a property function
\texttt{p\ ::\ ((a,b)\ -\textgreater{}\ r)}. Through the utilization of
this property function, a property function for \texttt{f} can be
derived by using the second selection function \texttt{g} to select a
corresponding \texttt{b} and subsequently applying \texttt{p} to assess
\texttt{(a,b)} pairs as follows:
\texttt{(\textbackslash{}x\ -\textgreater{}\ p\ (x,\ g\ (\textbackslash{}y\ -\textgreater{}\ p\ (x,y))))}.
Upon the determination of an optimal \texttt{a}, a corresponding
\texttt{b} can then be computed as
\texttt{g\ (\textbackslash{}y\ -\textgreater{}\ p\ (a,y))}. In this
case, the \texttt{pair} function can be conceptualized as a function
that constructs all possible combinations of the elements within the
provided selection function and subsequently identifies the overall
optimal one. It might feel intuitive to consider the following modified
\texttt{pair} function that seems to be more symmetric.

\begin{code}
pair' :: J r a -> J r b -> J r (a,b)
pair' f g p = (a,b)
  where
      a = f (\x -> p (x, g (\y -> p (x,y))))
      b = g (\y -> p (f (\x -> p (x,y)), y))
\end{code}

However, applying this modified \texttt{pair\textquotesingle{}} to our
previous example this results in a overall non optimal solution.

\begin{verbatim}
pair' p1 p2 pred
--> (Left,Left)
\end{verbatim}

This illustrates how the original \texttt{pair} function keeps track of
its first decision when determining its second element. It is noteworthy
that, in the example example, achieving a satisfying outcome for both
pedestrians is only possible when they consider the direction the other
one is heading. The specific destination does not matter, as long as
they are moving in different directions. Consequently, the original
\texttt{pair} function can be conceived as a function that selects the
optimal solution while retaining awareness of previous solutions,
whereas our modified \texttt{pair\textquotesingle{}} does not. An issue
with the original \texttt{pair} function might have been identified by
the attentive reader. There is redundant computational work involved.
Initially, all possible pairs are constructed to determine an optimal
first element \texttt{a}, but the corresponding \texttt{b} that renders
it an overall optimal solution is overlooked, resulting in only
\texttt{a} being returned. Subsequently, the optimal \texttt{b} is
recalculated based on the already determined optimal \texttt{a} when
selecting the second element of the pair. The primary contribution of
this paper will be to illustrate and propose a solution to this
inefficiency.

\subsection{Sequence}\label{sequence}

The generalization of the pair function to accommodate a sequence of
selection functions is the initial focus of exploration. In the context
of selection functions, a \texttt{sequence} operation is introduced,
capable of combining a list of selection functions into a singular
selection function that, in turn, selects a list of objects:

\begin{code}
sequence :: [J r a] -> J r [a]
sequence [] p     = []
sequence (e:es) p = a : as
  where 
      a  = e (\x -> p (x : sequence es (p . (x:))))
      as = sequence es (p . (a:))
\end{code}

Here, similar to the pair function, the sequence function extracts
elements from the resulting list through the corresponding selection
functions. This extraction is achieved by applying each function to a
newly constructed property function that possesses the capability to
foresee the future, thereby constructing an optimal future based on the
currently examined element. However, a notable inefficiency persists,
exacerbating the issue observed in the pair function. During the
determination of the first element, the \texttt{sequence} function
calculates an optimal remainder of the list, only to overlook it and
redundantly perform the same calculation for subsequent elements. This
inefficiency in \texttt{sequence} warrants further investigation for
potential optimization in subsequent sections of this research paper.

\subsection{Selection monad}\label{selection-monad}

The formation of a monad within the selection functions unfolds as
follows:

\begin{code}
(>>=) :: J r a -> (a -> J r b) -> J r b
(>>=) f g p = g (f (p . flip g p)) p
\end{code}

\begin{code}
return :: a -> J r a
return x p = x
\end{code}

These definitions illustrate the monadic structure inherent in selection
functions. The Haskell standard library already incorporates a built-in
function for monads, referred to as \texttt{sequence\textquotesingle{}},
defined as:

\begin{code}
sequence' :: [J r a] -> J r [a]
sequence' (ma:mas) = ma >>= 
                    \x -> sequence' mas >>= 
                    \xs -> return (x:xs)
\end{code}

Notably, in the case of the selection monad, this built-in
\texttt{sequence\textquotesingle{}} function aligns with the earlier
provided \texttt{sequence} implementation. This inherent consistency
further solidifies the monadic nature of selection functions,
underscoring their alignment with established Haskell conventions.

\subsection{Illustration of Sequence in the Context of Selection
Functions}\label{illustration-of-sequence-in-the-context-of-selection-functions}

To ilustrate the application of the sequence function within the domain
of selection functions, consider a practical scenario: the task of
cracking a secret password. In this hypothetical situation, a black box
predicate \texttt{p} is provided that returns \texttt{True} if the
correct password is entered and \texttt{False} otherwise. Additionally,
knowledge is assumed that the password is six characters long:

\begin{code}
p :: String -> Bool
p "secret" = True
p _        = False
\end{code}

Suppose access is available to a \texttt{maxWith} function, defined as:

\begin{code}
maxWith :: Ord r => [a] -> (a -> r) -> a
maxWith [x] f                      = x
maxWith (x:y:xs) f | (f x) > (f y) = maxWith (x:xs) f
                   | otherwise     = maxWith (y:xs) f
\end{code}

With these resources, a selection function denoted as
\texttt{selectChar} can be constructed, which, given a predicate that
evaluates each character, selects a single character satisfying the
specified predicate:

\begin{code}
selectChar :: J Bool Char
selectChar = maxWith ['a'..'z']
\end{code}

It's worth noting that the use of maxWith is facilitated by the ordered
nature of booleans in Haskell, where \texttt{True} is considered greater
than \texttt{False}. Leveraging this selection function, the sequence
function can be employed on a list comprising six identical copies of
\texttt{selectChar} to successfully crack the secret password. Each
instance of the selection function focuses on a specific character of
the secret password:

\begin{verbatim}
sequence (replicate 6 selectChar) p
-> "secret"
\end{verbatim}

This illustrative example not only showcases the practical application
of the \texttt{sequence} function within the domain of selection
functions but also emphasizes its utility in addressing real-world
problems, such as scenarios involving password cracking. Notably, there
is no need to explicitly specify a predicate for judging individual
character; rather, this predicate is constructed within the monads bind
definition, and its utilization is facilitated through the application
of the \texttt{sequence} function. Additionally, attention should be
drawn to the fact that this example involves redundant calculations.
After determining the first character of the secret password, the system
overlooks the prior computation of the entire password and initiates the
calculation anew for subsequent characters. To address this specific
inefficiency within the selection monad, concerning the pair and
sequence functions, two new variations of the selection monad will be
introduced. Initially, an examination of a new type, denoted as
\texttt{K}, will reveal its isomorphism to the selection monad
\texttt{J}. Subsequently, an exploration of the generalization of this
\texttt{K} type will enhance its intuitive usability. Remarkably, it
will be demonstrated that the \texttt{J} monad can be embedded into this
generalized \texttt{K} type.

\section{Special K}\label{special-k}

The following type \texttt{K} is to be considered:

\begin{code}
type K r a = forall b. (a -> (r,b)) -> b
\end{code}

While selection functions of type \texttt{J} are still in anticipation
of a predicate capable of judging their underlying elements, a similar
operation is performed by the new \texttt{K} type. The predicate of the
\texttt{K} type also assesses its elements by transforming them into
\texttt{r} values. Additionally, it converts the \texttt{x} into any
\texttt{y} and returns that \texttt{y} along with its judgment
\texttt{r}.

\begin{code}
pairK :: K r a -> K r b -> K r (a,b)
pairK f g p = f (\x -> 
              g (\y -> let (r, z) = p (x,y) 
                       in (r, (r,z))))
\end{code}

The previously mentioned inefficiency is now addressed by the definition
of \texttt{pairK}. This is achieved by examining every element
\texttt{x} in the selection function \texttt{f.} For each element, a
corresponding result is extracted from the second selection function
\texttt{g.} Utilizing the additional flexibility provided by the new
\texttt{K} type, the property function for \texttt{g} is now constructed
differently. Instead of merely returning the result \texttt{z} along
with the corresponding \texttt{r} value, a duplicate of the entire
result pair calculated by \texttt{p} is generated and returned. As this
duplicate already represents the complete solution, the entire result
for an optimal \texttt{x} can now be straightforwardly yielded by
\texttt{f,} eliminating the need for additional computations.

The sequenceK for this novel K type can be defined as follows:

\begin{code}
sequenceK :: [K r a] -> K r [a]
sequenceK [e] p    = e (\x -> p [x])
sequenceK (e:es) p = e (\x -> sequenceK es 
                       (\xs -> let (r,y) = p (x:xs) 
                               in (r,(r,y))))
\end{code}

This \texttt{sequenceK} implementation employs the same strategy as the
earlier \texttt{pairK} function. It essentially generates duplicates of
the entire solution pair, returning these in place of the result value.
The selection function one layer above then unpacks the result pair,
allowing the entire solution to be propagated. The efficiency issues
previously outlined are addressed by these novel \texttt{pairK} and
\texttt{sequenceK} functions. It will be further demonstrated that this
fresh \texttt{K} type is isomorphic to the preceding \texttt{J} type.
This essentially empowers the transformation of every problem previously
solved with the \texttt{J} type into the world of the \texttt{K} type.
Subsequently, the solutions can be computed more efficiently before
being transformed back to express them in terms of \texttt{J}.

\subsection{Special K is isomorphic to
J}\label{special-k-is-isomorphic-to-j}

To demonstrate the isomorphism between the new Special \texttt{K} type
and the \texttt{J} type, two operators are introduced for transforming
from one type to the other:

\begin{code}
j2k :: J r a -> K r a
j2k f p = snd (p (f (fst . p)))
\end{code}

When provided with a selection function \texttt{f} of type
\texttt{J\ r\ a}, the \texttt{j2k} operator constructs an entity of type
\texttt{K\ r\ a}. For a given
\texttt{f\ ::\ (a\ -\textgreater{}\ r)\ -\textgreater{}\ a} and
\texttt{p\ ::\ forall\ b.\ (a\ -\textgreater{}\ (r,b))}, the objective
is to return an entity of type \texttt{b}. This is achieved by initially
extracting an a from \texttt{f} using the constructed property function
\texttt{(fst\ .\ p)}. Subsequently, this a is employed to apply
\texttt{p}, yielding an \texttt{(r,b)} pair, from which the \texttt{b}
is obtained by applying \texttt{snd} to the pair. The transformation of
a selection function of type \texttt{K} into a selection function of
type \texttt{J} is accomplished as follows:

\begin{code}
k2j :: K r a -> J r a
k2j f p = f (\x -> (p x, x)) 
\end{code}

Given a selection function
\texttt{f\ ::\ forall\ b.\ (a\ -\textgreater{}\ (r,b))\ -\textgreater{}\ b}
and a \texttt{p\ ::\ (a\ -\textgreater{}\ r)\ -\textgreater{}\ a}, an
\texttt{a} can be directly extracted from \texttt{f} by constructing a
property function that utilizes \texttt{p} to obtain an \texttt{r} value
while leaving the corresponding \texttt{x} of type a untouched. To
validate that these two operators indeed establish an isomorphism
between \texttt{J} and \texttt{K}, the following equations must be
proven: \texttt{(k2j\ .\ j2k)\ f\ =\ f} and
\texttt{(j2k\ .\ k2j)\ g\ =\ g}.

\begin{proof}
The equality (k2j . j2k) f = f can be straightforwardly demonstrated by applying all the 
lambdas and the definitions of fst and snd:
  \begin{code}
  (k2j . j2k) f
  -- {{ Apply definitions}}
  = (\f p -> f (\x -> (p x, x))) (\p -> snd (p (f (fst . p))))
  -- {{ Simplyfy }}
  = f
  \end{code}
\end{proof}

This proof involves a direct application of lambda expressions and the
definitions of \texttt{fst} and \texttt{snd} for simplification. To
facilitate the proof of the second isomorphism, we initially introduce
the free theorem for the special K type:

\begin{theorem}[Free Theorem for `K`]
Given the following functions with thier corrisponding types:
  \begin{code}
  g :: forall y. (x -> (r, y)) -> y
  h :: Y1 -> Y2
  p :: x -> (r, Y1)
  \end{code}
  We have:
  \begin{code}
  h (g p) = g (\x -> (id *** g) (p x))
  \end{code}
\end{theorem}

With the free theorem for \texttt{K}, the other half of the isomorphism
can now be proven as follows:

\begin{proof}
The equality (j2k . k2j) g = g is established through the following steps:
  \begin{code}
  (j2k . k2j) g
  -- {{ Apply definitions and simplify}}
  = \p -> snd (p (g (\x -> ((fst . p) x, x))))
  -- {{ Free Theorem for K }}
  = \p -> g (\x -> ((fst . p) x, (snd . p) x))
  -- {{ Simplify }}
  = g
  \end{code}
\end{proof}

The monad definitions and \texttt{sequence} definition for the new
\texttt{K} type can be derived from the isomorphism. While the desired
performance improvements are achieved by the definition of \texttt{K},
significant data structure copying is required, only to be deconstructed
and discarded at a higher layer. This process significantly complicates
the associated definitions for \texttt{sequence} and \texttt{pair},
rendering them challenging to handle and lacking in intuitiveness.
Introducing another type, \texttt{GK}, that returns the entire tuple
rather than just the result value seems more intuitive. This exploration
is detailed in the following chapter, where similar performance
improvements are observed with \texttt{GK} while the definitions become
more straightforward. This approach also eliminates the need for
unnecessary copying of data. However, it is revealed that \texttt{GK} is
not isomorphic to \texttt{J} and \texttt{K}; instead, they can be
embedded into \texttt{GK}. Conversely, we will explore a specific
precondition under which \texttt{GK} can be embedded into \texttt{J} or
\texttt{K}.

\section{Generalised K}\label{generalised-k}

Consider the more general type \texttt{GK}, derived from the previous
special \texttt{K} type:

\begin{code}
type GK r a = forall b. (a -> (r,b)) -> (r,b)
\end{code}

Unlike its predecessor, \texttt{GK} returns the entire pair produced by
the predicate, rather than just the result value. The implementation of
\texttt{pairGK} for the new \texttt{GK} type no longer necessitates the
creation of a copy of the data structure. It suffices to return the
result of the predicate's application to the complete pair:

\begin{code}
pairGK :: GK r a -> GK r b -> GK r (a,b)
pairGK f g p = f (\x -> g (\y -> p (x,y)))
\end{code}

In terms of readability, this definition of pairGK is significantly more
concise, conveying the essence of the \texttt{pair} function without
unnecessary boilerplate code. For every element \texttt{x\ ::\ a} within
\texttt{f}, all \texttt{y\ ::\ b} within \texttt{g} are inspected and
judged by the given predicate \texttt{p}. The resulting pair selection
function returns the optimal pair of \texttt{(a,b)} values according to
the provided predicate. Furthermore, we define \texttt{sequenceGK} as
follows:

\begin{code}
sequenceGK :: [GK r a] -> GK r [a]
sequenceGK [e] p    = e (\x -> p [x])
sequenceGK (e:es) p = e (\x -> sequenceGK es (\xs -> p (x:xs)))
\end{code}

Following a similar pattern, this \texttt{sequenceGK} function builds
all possible futures for each element within \texttt{e}. Once an optimal
list of elements is found, this list is simply returned along with the
corresponding \texttt{r} value.

\begin{code}
bindGK :: GK r a -> (a -> GK r b) -> GK r b
bindGK e f p = e (\x -> f x p)
\end{code}

\begin{code}
returnGK :: a -> GK r a
returnGK x p = p x
\end{code}

\begin{itemize}
\item
  give pair and sequence
\item
  ilustrate how nice it is to deal with
\end{itemize}

\subsection{Relationship to J and Special
K}\label{relationship-to-j-and-special-k}

\begin{itemize}
\tightlist
\item
  Show that generalised K is an embedding
\end{itemize}

\begin{code}
-- k2gk :: K r a -> GK r a
-- k2gk f = snd . f
\end{code}

\begin{code}
-- gk2k :: GK r a -> K r a
-- gk2k f p =  f (\x -> let (r,y) = p x in (r, (r,y)))
\end{code}

\begin{itemize}
\tightlist
\item
  intoduce free theorem and precondition
\item
  counterexamples to ilustrate what precondition means and why we want
  it
\item
  introduce new theorem baced on free theorem and precondition
\item
  calculate monad definition from k2j and j2k
\end{itemize}

\section{Performance analisys}\label{performance-analisys}

\begin{itemize}
\tightlist
\item
  give some perfomance analysis examples that ilustrate improvement
\end{itemize}

\section{Related work}\label{related-work}

J was researched in the context of Sequential games, but slowly found
its way to other applications

\section{Outlook and future work}\label{outlook-and-future-work}

\begin{itemize}
\tightlist
\item
  Need to investigate further whats possible with the more general type
\item
  Alpha beta pruning as next step of my work
\end{itemize}

\section{Conclusion}\label{conclusion}

\begin{itemize}
\tightlist
\item
  We should use generalised K istead of J because more useful and more
  intuitive once understood
\item
  performance improvements are useful
\item
  monad pair and sequence implementation much more intuitive and useful
\end{itemize}

\section{Appendix}\label{appendix}

Proofs!\cite{escardo2010sequential}

%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
% \bibliographystyle{splncs04}
% \bibliography{mybibliography}
%
\bibliographystyle{splncs04}
\bibliography{bib}

\newpage
\section*{Appendix}
\appendix
\end{document}
