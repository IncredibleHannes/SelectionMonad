% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.20 of 2017/10/04
%
\documentclass[runningheads]{llncs}

\usepackage{listings}
\usepackage{textcomp}
\usepackage[english]{babel}

\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}

\lstnewenvironment{code}{\lstset{language=Haskell,basicstyle=\small\ttfamily}}{}
\lstnewenvironment{haskell}{\lstset{language=Haskell,basicstyle=\small\ttfamily}}{}
\newcommand{\ignore}[1]{}


\begin{document}

\title{Generalising the Selection Monad}

\author{
    Johannes Hartmann\inst{1} \and 
    Tom Schrijvers\inst{2}\and 
    Jeremy Gibbons\inst{1}
}
%
\authorrunning{J. Hartmann, T. Schrijvers, J. Gibbons}

\institute{
    University of Oxford, Department of Computer Science, UK
    \email{firstname.lastname@cs.ox.ac.uk}\and 
    KULeuven, Department of ComputerScience, Belgium,
    \email{tom.schrijvers@kuleuven.be}
}

%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
This paper explores a novel approach to selection functions through the
introduction of a generalized selection monad. The foundation is laid
with the conventional selection monad \texttt{J}, defined as
\texttt{(a\ -\textgreater{}\ r)\ -\textgreater{}\ a}, which employs a
pair function to compute new selection functions. However,
inefficiencies in the original pair function are identified. To address
these issues, a specialized type \texttt{K} is introduced, and its
isomorphism to \texttt{J} is demonstrated. The paper further generalizes
the \texttt{K} type to \texttt{GK}, where performance improvements and
enhanced intuitive usability are observed. The embedding between
\texttt{J} to \texttt{GK} is established, offering a more efficient and
expressive alternative to the well established \texttt{J} type for
selection functions. The findings emphasize the advantages of the
Generalized Selection Monad and its applicability in diverse scenarios,
paving the way for further exploration and optimization.

\keywords{Selection monad  \and Functional programming \and Algorithm design \and 
Performance Optimisation \and Monads.}
\end{abstract}
%
%
%
\ignore{

> {-# LANGUAGE ImpredicativeTypes #-}
> {-# LANGUAGE ScopedTypeVariables #-}

> import Prelude hiding ((>>=), return, pure, (<*>), fmap, sequence, pred)
> import Data.Function (on)
> import Data.List

}

\section{Introduction to the Selection
Monad}\label{introduction-to-the-selection-monad}

This section introduces the selection monad, focusing on the
\texttt{type\ J\ r\ a\ =\ (a\ -\textgreater{}\ r)\ -\textgreater{}\ a}
for selection functions \cite{escardo2010selection}. The \texttt{pair}
function is explored, showcasing its capability to compute new selection
functions based on criteria from two existing functions. Illustrated
with a practical example, the decision-making scenarios involving
individuals navigating paths underscore the functionality of selection
functions. An analysis of the inefficiency in the original \texttt{pair}
function identifies redundant computational work. The primary
contribution of the paper is then outlined: an illustration and proposal
for an efficient solution to enhance the \texttt{pair} functions
performance. This introductory overview sets the stage for a detailed
exploration of the selection monad and subsequent discussion on
optimizations.

\subsection{Selection functions}\label{selection-functions}

Consider the type for selection functions introduced by Paulo Olvia and
Martin Escardo \cite{escardo2010selection} :

\begin{code}
type J r a = (a -> r) -> a
\end{code}

Consider the following example. Two individuals are walking towards each
other on the pavement. A collision is imminent. At this juncture, each
individual must decide their next move. This decision-making process can
be modeled using selection functions. The decision they need to make is
going towards the street the or the wall:

\begin{code}
data Decision = Street | Wall deriving Show
\end{code}

The respective selection functions decide given a property function that
tells them what decision is the correct one, select the correct one, and
if there is no correct one, they default to walking towards the Wall.

\begin{code}
s :: J Bool Decision
s p = if p Street then Street else Wall
\end{code}

When given two selection functions, a \texttt{pair} function can be
defined to compute a new selection function. This resultant function
selects a pair based on the criteria established by the two given
selection functions:

\begin{code}
pair :: J r a -> J r b -> J r (a,b)
pair f g p = (a,b)
  where
      a = f (\x -> p (x, g (\y -> p (x,y))))
      b = g (\y -> p (a,y))
\end{code}

To apply the \texttt{pair} function, a property function \texttt{pred}
is needed that will judge two decisions and return \texttt{True} if a
crash is avoided and \texttt{False} otherwise.

\begin{code}
pred :: (Decision, Decision) -> Bool
pred (Wall,Street) = True
pred (Street,Wall) = True
pred _             = False
\end{code}

The \texttt{pair} function, merges the two selection functions into a
new one that calculates an\\
overall optimal decision.

\begin{verbatim}
ghci> pair s s pred
(Street,Wall)
\end{verbatim}

Examining how the \texttt{pair} function is defined reveals that the
first element \texttt{a} of the pair is determined by applying the
initial selection function \texttt{f} to a newly constructed property
function. Intuitively, selection functions can be conceptualized as
entities containing a collection of objects, waiting for a property
function to assess their underlying elements. Once equipped with a
property function, they can apply it to their elements and select an
optimal one. Considering the types assigned to selection functions, it
is evident that an initial selection function \texttt{f} remains in
anticipation of a property function of type
\texttt{(a\ -\textgreater{}\ r)} to determine an optimal \texttt{a}. The
\texttt{pair} function is endowed with a property function
\texttt{p\ ::\ ((a,b)\ -\textgreater{}\ r)}. Through the utilization of
this property function, a property function for \texttt{f} can be
derived by using the second selection function \texttt{g} to select a
corresponding \texttt{b} and subsequently applying \texttt{p} to assess
\texttt{(a,b)} pairs as follows:
\texttt{(\textbackslash{}x\ -\textgreater{}\ p\ (x,\ g\ (\textbackslash{}y\ -\textgreater{}\ p\ (x,y))))}.
Upon the determination of an optimal \texttt{a}, a corresponding
\texttt{b} can then be computed as
\texttt{g\ (\textbackslash{}y\ -\textgreater{}\ p\ (a,y))}. In this
case, the \texttt{pair} function can be conceptualized as a function
that constructs all possible combinations of the elements within the
provided selection function and subsequently identifies the overall
optimal one. It might feel intuitive to consider the following modified
\texttt{pair} function that seems to be more symmetric.

\begin{code}
pair' :: J r a -> J r b -> J r (a,b)
pair' f g p = (a,b)
  where
      a = f (\x -> p (x, g (\y -> p (x,y))))
      b = g (\y -> p (f (\x -> p (x,y)), y))
\end{code}

However, applying this modified \texttt{pair\textquotesingle{}} to our
previous example this results in a overall non optimal solution.

\begin{verbatim}
ghci> pair' p1 p2 pred
(Left,Left)
\end{verbatim}

This illustrates how the original \texttt{pair} function keeps track of
its first decision when determining its second element. It is noteworthy
that, in the example example, achieving a satisfying outcome for both
pedestrians is only possible when they consider the direction the other
one is heading. The specific destination does not matter, as long as
they are moving in different directions. Consequently, the original
\texttt{pair} function can be conceived as a function that selects the
optimal solution while retaining awareness of previous solutions,
whereas our modified \texttt{pair\textquotesingle{}} does not. An issue
with the original \texttt{pair} function might have been identified by
the attentive reader. There is redundant computational work involved.
Initially, all possible pairs are constructed to determine an optimal
first element \texttt{a}, but the corresponding \texttt{b} that renders
it an overall optimal solution is overlooked, resulting in only
\texttt{a} being returned. Subsequently, the optimal \texttt{b} is
recalculated based on the already determined optimal \texttt{a} when
selecting the second element of the pair. The primary contribution of
this paper will be to illustrate and propose a solution to this
inefficiency.

\subsection{Sequence}\label{sequence}

The generalization of the pair function to accommodate a sequence of
selection functions is the initial focus of exploration. In the context
of selection functions, a \texttt{sequence} operation is introduced,
capable of combining a list of selection functions into a singular
selection function that, in turn, selects a list of objects:

\begin{code}
sequence :: [J r a] -> J r [a]
sequence [] p     = []
sequence (e:es) p = a : as
  where 
      a  = e (\x -> p (x : sequence es (p . (x:))))
      as = sequence es (p . (a:))
\end{code}

Here, similar to the pair function, the sequence function extracts
elements from the resulting list through the corresponding selection
functions. This extraction is achieved by applying each function to a
newly constructed property function that possesses the capability to
foresee the future, thereby constructing an optimal future based on the
currently examined element. However, a notable inefficiency persists,
exacerbating the issue observed in the pair function. During the
determination of the first element, the \texttt{sequence} function
calculates an optimal remainder of the list, only to overlook it and
redundantly perform the same calculation for subsequent elements. This
inefficiency in \texttt{sequence} warrants further investigation for
potential optimization in subsequent sections of this research paper.

\subsection{Selection monad}\label{selection-monad}

The formation of a monad within the selection functions unfolds as
follows \cite{escardo2010selection}:

\begin{code}
(>>=) :: J r a -> (a -> J r b) -> J r b
(>>=) f g p = g (f (p . flip g p)) p
\end{code}

\begin{code}
return :: a -> J r a
return x p = x
\end{code}

These definitions illustrate the monadic structure inherent in selection
functions. The Haskell standard library already incorporates a built-in
function for monads, referred to as \texttt{sequence\textquotesingle{}},
defined as:

\begin{code}
sequence' :: [J r a] -> J r [a]
sequence' (ma:mas) = ma >>= 
                    \x -> sequence' mas >>= 
                    \xs -> return (x:xs)
\end{code}

Notably, in the case of the selection monad, this built-in
\texttt{sequence\textquotesingle{}} function aligns with the earlier
provided \texttt{sequence} implementation. This inherent consistency
further solidifies the monadic nature of selection functions,
underscoring their alignment with established Haskell conventions.

\subsection{Illustration of Sequence in the Context of Selection
Functions}\label{illustration-of-sequence-in-the-context-of-selection-functions}

To ilustrate the application of the sequence function within the domain
of selection functions, consider a practical scenario
\cite{hartmann2022algorithm}: the task of cracking a secret password. In
this hypothetical situation, a black box property function \texttt{p} is
provided that returns \texttt{True} if the correct password is entered
and \texttt{False} otherwise. Additionally, knowledge is assumed that
the password is six characters long:

\begin{code}
p :: String -> Bool
p "secret" = True
p _        = False
\end{code}

Suppose access is available to a \texttt{maxWith} function, defined as:

\begin{code}
maxWith :: Ord r => [a] -> (a -> r) -> a
maxWith xs f = snd (maximumBy (compare `on` fst) (map (\x -> (f x , x)) xs))
\end{code}

With these resources, a selection function denoted as
\texttt{selectChar} can be constructed, which, given a property function
that evaluates each character, selects a single character satisfying the
specified property function:

\begin{code}
selectChar :: J Bool Char
selectChar = maxWith ['a'..'z']
\end{code}

It's worth noting that the use of maxWith is facilitated by the ordered
nature of booleans in Haskell, where \texttt{True} is considered greater
than \texttt{False}. Leveraging this selection function, the sequence
function can be employed on a list comprising six identical copies of
\texttt{selectChar} to successfully crack the secret password. Each
instance of the selection function focuses on a specific character of
the secret password:

\begin{verbatim}
ghci> sequence (replicate 6 selectChar) p
"secret"
\end{verbatim}

This illustrative example not only showcases the practical application
of the \texttt{sequence} function within the domain of selection
functions but also emphasizes its utility in addressing real-world
problems, such as scenarios involving password cracking. Notably, there
is no need to explicitly specify a property function for judging
individual character; rather, this property function is constructed
within the monads bind definition, and its utilization is facilitated
through the application of the \texttt{sequence} function. Additionally,
attention should be drawn to the fact that this example involves
redundant calculations. After determining the first character of the
secret password, the system overlooks the prior computation of the
entire password and initiates the calculation anew for subsequent
characters. To address this specific inefficiency within the selection
monad, concerning the pair and sequence functions, two new variations of
the selection monad will be introduced. Initially, an examination of a
new type, denoted as \texttt{K}, will reveal its isomorphism to the
selection monad \texttt{J}. Subsequently, an exploration of the
generalization of this \texttt{K} type will enhance its intuitive
usability. Remarkably, it will be demonstrated that the \texttt{J} monad
can be embedded into this generalized \texttt{K} type.

\section{Special K}\label{special-k}

The following type \texttt{K} is to be considered:

\begin{code}
type K r a = forall b. (a -> (r,b)) -> b
\end{code}

While selection functions of type \texttt{J} are still in anticipation
of a property function capable of judging their underlying elements, a
similar operation is performed by the new \texttt{K} type. The property
function of the \texttt{K} type also assesses its elements by
transforming them into \texttt{r} values. Additionally, it converts the
\texttt{a} into any \texttt{b} and returns that \texttt{y} along with
its judgment \texttt{r}.

\begin{code}
pairK :: K r a -> K r b -> K r (a,b)
pairK f g p = f (\x -> 
              g (\y -> let (r, z) = p (x,y) 
                       in (r, (r,z))))
\end{code}

The previously mentioned inefficiency is now addressed by the definition
of \texttt{pairK}. This is achieved by examining every element
\texttt{x} in the selection function \texttt{f.} For each element, a
corresponding result is extracted from the second selection function
\texttt{g.} Utilizing the additional flexibility provided by the new
\texttt{K} type, the property function for \texttt{g} is now constructed
differently. Instead of merely returning the result \texttt{z} along
with the corresponding \texttt{r} value, a duplicate of the entire
result pair calculated by \texttt{p} is generated and returned. As this
duplicate already represents the complete solution, the entire result
for an optimal \texttt{x} can now be straightforwardly yielded by
\texttt{f,} eliminating the need for additional computations.

The \texttt{sequenceK} for this novel \texttt{K} type can be defined as
follows:

\begin{code}
sequenceK :: [K r a] -> K r [a]
sequenceK [e] p    = e (\x -> p [x])
sequenceK (e:es) p = e (\x -> sequenceK es 
                       (\xs -> let (r,y) = p (x:xs) 
                               in (r,(r,y))))
\end{code}

This \texttt{sequenceK} implementation employs the same strategy as the
earlier \texttt{pairK} function. It essentially generates duplicates of
the entire solution pair, returning these in place of the result value.
The selection function one layer above then unpacks the result pair,
allowing the entire solution to be propagated. The efficiency issues
previously outlined are addressed by these novel \texttt{pairK} and
\texttt{sequenceK} functions. It will be further demonstrated that this
fresh \texttt{K} type is isomorphic to the preceding \texttt{J} type.
This essentially empowers the transformation of every problem previously
solved with the \texttt{J} type into the world of the \texttt{K} type.
Subsequently, the solutions can be computed more efficiently before
being transformed back to express them in terms of \texttt{J}.

\subsection{Special K is isomorphic to
J}\label{special-k-is-isomorphic-to-j}

To demonstrate the isomorphism between the new Special \texttt{K} type
and the \texttt{J} type, two operators are introduced for transforming
from one type to the other:

\begin{code}
j2k :: J r a -> K r a
j2k f p = snd (p (f (fst . p)))
\end{code}

When provided with a selection function \texttt{f} of type
\texttt{J\ r\ a}, the \texttt{j2k} operator constructs an entity of type
\texttt{K\ r\ a}. For a given
\texttt{f\ ::\ (a\ -\textgreater{}\ r)\ -\textgreater{}\ a} and
\texttt{p\ ::\ forall\ b.\ (a\ -\textgreater{}\ (r,b))}, the objective
is to return an entity of type \texttt{b}. This is achieved by initially
extracting an a from \texttt{f} using the constructed property function
\texttt{(fst\ .\ p)}. Subsequently, this a is employed to apply
\texttt{p}, yielding an \texttt{(r,b)} pair, from which the \texttt{b}
is obtained by applying \texttt{snd} to the pair. The transformation of
a selection function of type \texttt{K} into a selection function of
type \texttt{J} is accomplished as follows:

\begin{code}
k2j :: K r a -> J r a
k2j f p = f (\x -> (p x, x)) 
\end{code}

Given a selection function
\texttt{f\ ::\ forall\ b.\ (a\ -\textgreater{}\ (r,b))\ -\textgreater{}\ b}
and a \texttt{p\ ::\ (a\ -\textgreater{}\ r)\ -\textgreater{}\ a}, an
\texttt{a} can be directly extracted from \texttt{f} by constructing a
property function that utilizes \texttt{p} to obtain an \texttt{r} value
while leaving the corresponding \texttt{x} of type a untouched. To
validate that these two operators indeed establish an isomorphism
between \texttt{J} and \texttt{K}, the following equations must be
proven: \texttt{(k2j\ .\ j2k)\ f\ =\ f} and
\texttt{(j2k\ .\ k2j)\ g\ =\ g}.

\begin{proof}[J to K Embedding]
The equality (k2j . j2k) f = f can be straightforwardly demonstrated by applying all the 
lambdas and the definitions of fst and snd:

\begin{haskell}
(k2j . j2k) f
{{Apply definitions}}
= (\f p -> f (\x -> (p x, x))) (\p -> snd (p (f (fst . p))))
{{Simplify }}
= f
\end{haskell}

\end{proof}

This proof involves a direct application of lambda expressions and the
definitions of \texttt{fst} and \texttt{snd} for simplification. To
facilitate the proof of the second isomorphism, we initially introduce
the free theorem for the special K type \cite{wadler1989theorems}:

\begin{theorem}[Free Theorem for K]
Given the following functions with their corresponding types:

\begin{haskell}
g :: forall b. (a -> (r, b)) -> b
h :: b1 -> b2
p :: a -> (r, b1)
\end{haskell}

We have:

\begin{haskell}
h (g p) = g (\x -> let (r,y) = (p x) in (r,h y))
\end{haskell}

\end{theorem}

The free theorem essentially asserts that a function
\texttt{h\ ::\ y1\ -\textgreater{}\ y2}, when applied to the result of a
selection function, can also be incorporated into the property function
and applied to each individual element. This follows from the
generalized type of \texttt{K}, where the only means of generating
\texttt{y1} values is through the application of \texttt{p}.
Consequently, it becomes inconsequential whether h is applied to the
final result or to each individual intermediate result. With the free
theorem for \texttt{K}, the remaining portion of the isomorphism can now
be demonstrated as follows:

\begin{proof}[K to J Embedding]
The equality (j2k . k2j) g = g is established through the following steps:

\begin{haskell}
(j2k . k2j) g
{{Apply definitions and simplify}}
= \p -> snd (p (g (\x -> ((fst . p) x, x))))
{{Free Theorem for K }}
= \p -> g (\x -> ((fst . p) x, (snd . p) x))
{{Simplify }}
= g
\end{haskell}

\end{proof}

The monad definitions and \texttt{sequence} definition for the new
\texttt{K} type can be derived from the isomorphism. While the desired
performance improvements are achieved by the definition of \texttt{K},
significant data structure copying is required, only to be deconstructed
and discarded at a higher layer. This process significantly complicates
the associated definitions for \texttt{sequence} and \texttt{pair},
rendering them challenging to handle and lacking in intuitiveness.
Introducing another type, \texttt{GK}, that returns the entire tuple
rather than just the result value seems more intuitive. This exploration
is detailed in the following section, where similar performance
improvements are observed with \texttt{GK} while the definitions become
more straightforward. This approach also eliminates the need for
unnecessary copying of data. However, it is revealed that \texttt{GK} is
not isomorphic to \texttt{J} and \texttt{K}; instead, they can be
embedded into \texttt{GK}. Conversely, we will explore a specific
precondition under which \texttt{GK} can be embedded into \texttt{J} or
\texttt{K}.

\section{Generalised K}\label{generalised-k}

Consider the more general type \texttt{GK}, derived from the previous
special \texttt{K} type:

\begin{code}
type GK r a = forall b. (a -> (r,b)) -> (r,b)
\end{code}

Unlike its predecessor, \texttt{GK} returns the entire pair produced by
the property function, rather than just the result value. The
implementation of \texttt{pairGK} for the new \texttt{GK} type no longer
necessitates the creation of a copy of the data structure. It suffices
to return the result of the property function's application to the
complete pair:

\begin{code}
pairGK :: GK r a -> GK r b -> GK r (a,b)
pairGK f g p = f (\x -> g (\y -> p (x,y)))
\end{code}

In terms of readability, this definition of pairGK is significantly more
concise, conveying the essence of the \texttt{pair} function without
unnecessary boilerplate code. For every element \texttt{x\ ::\ a} within
\texttt{f}, all \texttt{y\ ::\ b} within \texttt{g} are inspected and
judged by the given property function \texttt{p}. The resulting pair
selection function returns the optimal pair of \texttt{(a,b)} values
according to the provided property function. Furthermore, we define
\texttt{sequenceGK} as follows:

\begin{code}
sequenceGK :: [GK r a] -> GK r [a]
sequenceGK [e] p    = e (\x -> p [x])
sequenceGK (e:es) p = e (\x -> sequenceGK es (\xs -> p (x:xs)))
\end{code}

Following a similar pattern, this \texttt{sequenceGK} function builds
all possible futures for each element within \texttt{e}. Once an optimal
list of elements is found, this list is simply returned along with the
corresponding \texttt{r} value.

\subsection{Relationship to J and Special
K}\label{relationship-to-j-and-special-k}

With the following operators, selection functions of type \texttt{K} can
be embedded into \texttt{GK}.

\begin{code}
gk2k :: forall r a b. ((a -> (r,b)) -> (r,b)) -> ((a -> (r,b)) -> b)
gk2k f = snd . f
\end{code}

\begin{code}
k2gk :: K r a -> GK r a
k2gk f p = f (\x -> let (r,y) = p x in (r, (r,y)))
\end{code}

Similar to the free theroem for the \texttt{K} type, it is also possible
to derive the free theorem for the \texttt{GK} type:

\begin{theorem}[Free Theorem for GK]
Given the following functions with thier corresponding types:

\begin{haskell}
g :: forall b. (\a -> (r,b)) -> (r,b)
f :: b1 -> b2
p :: a -> (r, b1)
\end{haskell}

We have:

\begin{haskell}
((id *** f) . g) p = g ((id *** f) . p)
\end{haskell}

\end{theorem}

It is basically stating the same as the free Theorem for \texttt{K},
where given a function \texttt{f} that is applied to the result of a
selection function, it dosent matter if this is done in the end to the
final result, or inside the property function of the selection function.
But it now needs to account for the fact that the \texttt{GK} type is
also returning the \texttt{r} value.

With the free theorem for \texttt{GK} we can now proof that selection
functions of type \texttt{K} can be embedded into \texttt{GK}:

\begin{proof}[K to GK Embedding]
The equality (k2gk . gk2k) f = f is established through the following steps:

Assuming: f :: K r a

\begin{haskell}
(gk2k . k2gk) f
{{ Definitions and rewrite }}
= (\p -> (snd . f) (\x -> let (r,y) = p x in (r, (r,y)))) 
{{ Free theorem of GK }}
= (\p -> f (\x -> let (r,y) = p x in (r, snd (r,y))))
{{ Simplify }}
= f
\end{haskell}
\end{proof}

Embedding \texttt{K} selection functions into the new \texttt{GK} type
is a little bit more tricky. We essentially need to make sure that
\texttt{g} is not changing the \texttt{r} value after applying
\texttt{p} to it's elements. Therefore

\begin{proof}[GK to K Embedding]
The equality (k2gk . gk2k) g = g is established through the following steps:

Assuming that for 
g :: GK r a
forall p :: forall b . (a -> (r,b))
exists x :: a
such that:
g p = p x

\begin{haskell}
(k2gk . gk2k) g
{{ Definitions and rewrite }}
= \p -> snd (g(\x -> let (r,y) = p x in (r, (r,y))))
{{ Assumption }}
= \p -> snd (exist x -> let (r,y) = p x in (r, (r,y)))
{{ exists commuts }}
= \p -> exists x -> let (r,y) = p x in snd (r, (r,y))
{{ Assumption }}
= \p -> g (\x -> let (r,y) = p x in snd (r, (r,y)))
{{ Simplify }}
= g
\end{haskell}
\end{proof}

\begin{itemize}
\tightlist
\item
  counterexamples to ilustrate what precondition means and why we want
  it
\item
  introduce new theorem baced on free theorem and precondition
\item
  calculate monad definition from k2j and j2k
\end{itemize}

\section{GK forms a monad}\label{gk-forms-a-monad}

The monad definition for \texttt{GK} is straightforward:

\begin{code}
bindGK :: GK r a -> (a -> GK r b) -> GK r b
bindGK e f p = e (\x -> f x p)
\end{code}

Given a selection function \texttt{e\ ::\ GK\ r\ a}, a function
\texttt{f\ ::\ a\ -\textgreater{}\ GK\ r\ b}, and a property function\\
\texttt{p\ ::\ forall\ c.\ (b\ -\textgreater{}\ (r,c))}, the result of
type \texttt{(r,c)} can be constructed by utilizing \texttt{e}. Each
underlying element \texttt{x\ ::\ a} of \texttt{e} will be assessed
based on the values produced by applying \texttt{f} to each element
\texttt{x}. This process results in a pair comprising the \texttt{r}
value by which the outcome is judged and the result value of type
\texttt{c}. Since this pair is already of the correct type, it is
sufficient to simply return it.

\begin{code}
returnGK :: a -> GK r a
returnGK x p = p x
\end{code}

The proofs for the monad laws are attached in the appendix.

With these monad definitions, we'd like to investigate how they relate
to the definitions for \texttt{J} or \texttt{K} respectively. We'd like
the \texttt{GK} monad to behave in the same way as the \texttt{J} and
\texttt{K} monad does.

In order to dirive we need to introduce the following two theorems:

\begin{theorem}[Theorem 1]
\begin{haskell}
f :: (r,a) -> (r,b)
g :: K r x
p :: x -> (r,a)
f (g p) = g (f . p)
\end{haskell}
iff (fst . f . p) = fst . p

\end{theorem}

\begin{proof}[Theorem 1]
\begin{haskell}
Assuming that for 
g :: GK r a
forall p :: forall b . (a -> (r,b))
exists x :: a
such that:
g p = p x

f (g p)
{{ Assumption }}
= exists x -> f (p x)
{{ rewrite as tuple }}
= ((fst . f . p) x, (snd . f . p) x)
{{ Theorem 1 condition }}
= ((fst . p ) x , (snd . f . p) x)                                                   
{{ rewrite as let }}
= let (r, y) = p x in (r, snd (f (r,y)))                                             
{{ rewrite as *** }}
= let (r, y) = p x in (id *** (\y -> snd (f (r,y)))) (r, y)                          
{{ resolve *** }}
= let (r, y) = p x in (\(a,b) -> (a, (\y -> snd (f (r,y))) b)) (r, y)                
{{ apply lambda }}
= let (r, y) = p x in (\(a,b) -> (a, snd (f (r,b)))) (r, y)                          
{{ expand let }}
= let r = fst (p x) in let y = snd (p x) in (\(a,b) -> (a, snd (f (r,b)))) (r, y)    
{{ remove let }}
= (\(a,b) -> (a, snd (f (fst (p x), b)))) ((fst (p x)), (snd (p x)))                 
{{ simplify }}
= (\(a,b) -> (a, snd (f (fst (p x), b)))) p x                                        
{{ remove patternmatch in lambda }}
= (\a -> (fst a, snd (f (fst (p x), snd a)))) p x                                   
{{ replace (p x) with a within lambda }}
= (\a -> (fst a, snd (f (fst a, snd a)))) p x                                        
{{ add patternmatch to lamvda }}
= (\(r,y) -> (r, snd (f (r, y)))) p x                                                
{{ Assumption }}
= (\(r,y) -> (r, snd (f (r, y)))) g p                                                
{{ free Theorem for GK }}
= g ((\(r,y) -> (r,  snd (f (r,y)))) . p)                                            
{{ rewrite (.) }}
= g (\x -> (\(r,y) -> (r,  snd (f (r,y)))) (p x))                                    
{{ pull (p x) into lambda }}
= g (\x -> (fst (p x),  snd (f (fst (p x) ,snd (p x)))))                             
{{ simplify tuple to p x }}
= g (\x -> (fst (p x),  snd (f (p x))))                                              
{{ rewrite with (.) }}
= g (\x -> ((fst . p) x, (snd . f . p) x))                                           
{{ expand first bit with theorem condition }}
= g (\x -> ((fst . f . p) x, (snd . f . p) x))                                       
{{ simplify tuple to (f . p) x }}
= g (\x -> (f . p) x)                                                                
{{ remove lambda }}
= g (f . p)
\end{haskell}
\end{proof}

To further simplify the calculation we aslso introduce the following
theorem:

\begin{theorem}[Theorem 2]
If q does apply p to get the r value but keeps the original value, and we then use that 
original value to compute the (r,z) values with p we can call g with p directly
\begin{haskell}

-- p :: x -> (r,y)
-- g :: K r x
-- p (snd (g q)) = g p
--    where q = (\x -> ((fst . p) x, x))
\end{haskell}
\end{theorem}

And we can proof Theorem 2 by utilising Theorem 1.

\begin{proof}[Theorem 1]
\begin{haskell}
(p . snd) (g q)
= g (\x -> (p . snd) ((fst . p) x, x))
= g p

iff 
(fst . p . snd) (\x -> ((fst . p) x, x))
= \y -> (fst ( p (snd ( (\x -> ((fst . p) x, x)) y))))
= \y -> (fst(p(snd ((fst . p) y, y) )))
= \x -> (fst . p) x
= fst . (\x -> ((fst . p) x, x)) 
\end{haskell}
\end{proof}

-- TODO: Give an intuition what these theorems mean

Now, consider the following two operators that transform between
\texttt{GK} selection functions and \texttt{J} selection functions:

\begin{code}
j2gk :: J r x -> GK r x
j2gk f p = p (f (fst . p))
\end{code}

\begin{code}
gk2j :: GK r x -> J r x
gk2j f p = snd (f (\x -> (p x, x)))
\end{code}

We can calculate the bind implementation for \texttt{GK} with the
\texttt{j2gk} and \texttt{gk2j} operators and the previusly introduced
theorems:

\begin{proof}[GK Monad behaves similar to J]
\begin{haskell}
j2gk ((>>=) (gk2j f) (\x -> gk2j (g x)))                                                         
{{ Definition of (>>=) }}
= j2gk ((\f g p -> g (f (p . flip g p)) p) (gk2j f) (\x -> gk2j (g x)))
{{ Simplify }}
= j2gk (\p -> gk2j (g (gk2j f (p . (\x -> gk2j (g x) p)))) p)
{{ Definition of j2gk and rewrite }}
= \p -> p (gk2j (g (gk2j f (\x -> fst ((p . snd) ((g x) (\x -> ((fst . p) x, x))))))) (fst . p))
{{ Theorem 1 }}
= \p -> p (gk2j (g (gk2j f (\x -> fst (((g x) (\x -> (p . snd) ((fst . p) x, x))))))) (fst . p))
{{Definition of j2gk and rewrite }}                  
= \p -> p (snd (g (snd (f (\x -> (fst (g x p), x)))) (\x -> ((fst . p) x, x))))
{{ Theorem 2 }}
= \p -> g (snd (f (\x -> (fst (g x p), x)))) p
{{ Rewrite }}
= \p -> (\y -> g (snd y) p) (f (\x -> (fst (g x p), x)))
{{ Theorem 1 }}
= \p -> f ((\y -> g (snd y) p) . (\x -> (fst (g x p), x)))  
{{ Simplify }}
\p -> f (\x -> g x p)
\end{haskell}
\end{proof}

This shows that all \texttt{GK} selection functions behave the same when
transforemd to \texttt{K} or \texttt{J} selection functions.

\begin{itemize}
\tightlist
\item
  TODO: ilustrate how nice it is to deal with
\end{itemize}

\section{Performance analisys}\label{performance-analisys}

\begin{itemize}
\tightlist
\item
  give some perfomance analysis examples that ilustrate improvement
\item
  Done by an example and use trace to count calls of P
\end{itemize}

\section{Related work}\label{related-work}

\begin{itemize}
\item
  J was researched in the context of Sequential games, but slowly found
  its way to other applications
\item
  It can also be used for greedy algorythms, however this performance
  optimisation does not apply in this case
\item
  But greedy algorythms can also be represented with the new generalised
  selection monad
\end{itemize}

\section{Outlook and future work}\label{outlook-and-future-work}

\begin{itemize}
\tightlist
\item
  Need to investigate further whats possible with the more general type
\item
  Alpha beta pruning as next step of my work
\end{itemize}

\section{Conclusion}\label{conclusion}

\begin{itemize}
\tightlist
\item
  We should use generalised K istead of J because more useful and more
  intuitive once understood
\item
  performance improvements are useful
\item
  monad, pair, and sequence implementation much more intuitive and
  useful
\end{itemize}

%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
% \bibliographystyle{splncs04}
% \bibliography{mybibliography}
%
\bibliographystyle{splncs04}
\bibliography{bib}

\newpage
\section*{Appendix}
\appendix
\subsection*{Proof Monad Laws for GK}\label{GK-monad-laws}
\begin{proof}[Left identity]
\begin{haskell}
return a >>= h
= (flip ($)) a >>= h
= (\p -> p a) >>= h
= \p' -> (\p -> p a) ((flip h) p')
= \p' -> ((flip h) p') a
= \p' -> h a p'
= h a
\end{haskell}
\end{proof}
\begin{proof}[Right identity]
\begin{haskell}
m >>= return
= \p -> m ((flip return) p)
= \p -> m ((flip (flip ($))) p)
= \p -> m (($) p)
= \p -> m p
= m
\end{haskell}
\end{proof}
\begin{proof}[Associativity]
\begin{haskell}
(m >>= g) >>= h
= \p -> (m >>= g) ((flip h) p)
= \p -> (\p' -> m ((flip g) p')) ((flip h) p)
= \p -> (m ((flip g) ((flip h) p)))
= \p -> m ((\y x -> g x y) ((flip h) p))
= \p -> m ((\x -> g x ((flip h) p)))
= \p -> m ((\p' x -> (g x) ((flip h) p')) p)
= \p -> m ((flip (\x p' -> (g x) ((flip h) p'))) p)
= \p -> m ((flip (\x -> (\p' -> (g x) ((flip h) p')))) p)
= \p -> m ((flip (\x -> g x >>= h)) p)
= m >>= (\x -> g x >>= h)
\end{haskell}
\end{proof}
\end{document}
